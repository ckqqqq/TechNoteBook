# 实验六

p [7, 23, 31237, 7326648629, 8362146254299, 2134292280629738893, 4842728516835152219, 1565311115845047984328660883269, 20205960090658806057524354765674817291]
a [6, 20, 10262, 3364966368, 2765028937696, 1638167494179592873, 2235386213174308342, 1025785367854775103377881264759, 3829749491673332569380016515044597590]
B生成的公钥为 [6, 19, 17968, 6267123883, 5085266861053, 462892760796290051, 1928913852294686272, 1468891151529904576281753399611, 13156091409125220711352545637358124583]
A生成的公钥为 [6, 17, 18940, 1401674101, 2028269338460, 638278166633946993, 2782137292398286670, 44714604696691990501727744674, 13593345005873474473388412908498831206]

## 实验环境

1、操作系统不限；

2、编程语言不限，为方便进行大数运算，建议使用 Java 或 Python。

实验方法和步骤

编写一段程序，模拟 Diffie-Hellman 算法交换密钥的过程，主要 要求如下（步骤 4 供有兴趣的同学尝试，不是必做内容）：

1、根据选择的大素数 p，生成其元根 a；

2、通信双方 Alice 和 Bob 随机生成自己的私钥 Xa 和 Xb，计算 公开密钥 Ya 和 Yb，并将其传给对方；

3、Alice 和 Bob 接收到对方传来的公开密钥之后，计算共享密钥 K，观察计算得到的 K 是否一致；

4、假设你是一个攻击者，掌握了公开的 p 和 a，又截获了 Alice 和 Bob 传递的公开密钥 YA 和 YB，那么你距离破译密钥只差 计算出 XA 或 XB，从小到大尝试不同的素数 p，体验对大素 数计算离散对数的难度，进而体会大素数 p 的选择对算法安 全性的影响

##  生成大质数

推荐一个生成质数的网站

2134292280629738893

4842728516835152219

8362146254299

7326648629

31237

23

[Wolfram|Alpha: Computational Intelligence (wolframalpha.com)](https://www.wolframalpha.com/)

=

28954 62836 35373 08201 41893 03137

30*3=64

a的n-1次方模n 一定是1

 

对于 a^j ≡ a^I (mod p)，则 i≡j(mod p−1)。这里有两个例子：

7 mod  3

3是7的原根，因为3–>2–>6–>4–>5–>1，然后开始循环

2不是7的原根，因为2–>4–>1–>2–>4–>1，过早的循环了

对 于 素 数 p a p − 1 ≡ 1 （ m o d  p ） 对于素数p\\a^{p-1} ≡ 1 （mod\ \ p）\\

对于素数p

a 

p−1 ≡1（mod p）

 

原根在p-1之前不会有循环

 

也就是原根的循环节为 p−1，非原根有较小的循环节，且是 p−1 的约数（因为元素的阶整除群的阶）

实验⽬的

通过模拟两个客户之间的加密会话过程，理解安全密钥交换的重要性，理解基于Diffie-Hellman协议的安全密钥交换的原理和流程。

实验原理

⽤Diffie-Hellman协议进⾏密钥交换的过程简述如下：

符号解释 

$$ p:大素数 $$

$$ a:原根 $$

$$ X_{i}:i随机生成的私钥 $$

$$ Y_{i}:i公开的公钥 $$



### 原根定义：

设 $m \in \mathbb{N}^{*} ， a \in \mathbb{Z}_{\text {。若 }} \operatorname{gcd}(a, m)=1$ ，且 $\delta_{m}(a)=\varphi(m)$ ，则称 $a$ 为模 $m$ 的原根。

### 原根判定定理：

设 $m \geqslant 3, \operatorname{gcd}(a, m)=1$ ，则 $a$ 是模 $m$ 的原根的充要条件是，对于 $\varphi(m)$ 的每个素因数 $p$ ，都有 $a^{\frac{\varphi(m)}{p}} \not \equiv 1(\bmod m) 。$

### 生成原根的代码

pass

### Diffie-Hellman 算法交换密钥的流程

选取两个⼤数p和a并公开，其中p是⼀个素数，g是a的⼀个(模p本原单位根)，所谓本原单位根就是指在模p乘法运算下，a的1次⽅，2次⽅……(p-1)次⽅这p-1个数互不相同，并且取遍1到p-1；

对于Alice(其中的⼀个通信者)，随机产⽣⼀个整数$$X_a，X_a$$对外保密，计算
$$
Ya = a^{X_a} mod p
$$
将$$Y_a$$发送给Bob；

对于Bob(另⼀个通信者)，随机产⽣⼀个整数$$X_b，X_b$$对外保密，计算
$$
Yb = a^{X_b} mod p
$$
，将$$Y_b$$发送给Alice；

在Alice⽅⾯，收到Bob送来的$$Y_b$$后，计算出密钥为：
$$
K = Y_b^{X_a} mod p=(a^{X_b})^{X_a}=a^{X_b*X_a} mod   p
$$
对于Bob，收到Alice送来的$$Y_a$$后，计算出密钥为：
$$
K= Y_a ^ {X_b} mod  p=(a^{X_{a}})^{x_b}=g^{a*b} mod p
$$
攻击者知道$$p和a，并且截获了Y_a和Y_b$$，但是当它们都是⾮常⼤的数的时候，依靠这四个数来计算a和b⾮常困难，这就是离散对数数学难题。

## 算法优化一：模n快速幂/模n快速求余：

快速模幂算法也是从⼿算中总结出规律来，例如：

5^8 = (5^2)^4 = (25)^4 = (25^2)^2 = (625)^2，这样，原来计算5^8需要做8次乘法，⽽现在则只需要三次乘法，时间复杂度变化为
$$
O(n) -》O(log)
$$

## 算法优化二：根据原根判定定理快速求原根/生成元

原根判定定理参考

[原根 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/primitive-root/)

## 算法三：如何快速求离散对数？二分法

如果我们成为了攻击者，问题则转化为了如何求如下同余方程的最小解
$$
Y=a^{X}(modp)
$$

$$
X \in[1,1-p]
$$



由于X是随机生成的，如果暴力遍历的话复杂度是$$O(p)$$,但是下面我们采用分治的思想，将复杂度降到$$O(p^{1/2})$$

令
$$
Z=向上取整(\sqrt{q})
$$
引入变量$$X_{1}和X_{2}$$,使得下列等式成立
$$
X=X_{1}*Z-X{2}
$$
故原有的同余方程
$$
Y=a^{X}(modp)=a^{(X_{1}*Z-X_{2})}(modp)
$$
即是
$$
Y^{X_{2}}=a^{X}(modp)=(a^{Z})^{X_{1}}(modp)
$$
又由于
$$
X_{1}、X{2} \in[1,p^{1/2}]
$$
所以我们只需要遍历一遍$$X_{2}$$，把它的值存入哈希表中，然后遍历一遍$$X_{1}$$到哈希表中找对应的值就行了。



引用1BabyStep算法的维基百科

https://en.wikipedia.org/wiki/Baby-step_giant-step

引用2原根

[原根 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/primitive-root/)

