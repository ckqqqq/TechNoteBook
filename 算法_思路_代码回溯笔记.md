

## Loss

`Pytorch 1.x` 的多机多卡计算模型并没有采用主流的 `Parameter Server` 结构，而是直接用了`Uber Horovod` 的形式，也是百度开源的 `RingAllReduce` 算法。

采用 `PS` 计算模型的分布式，通常会遇到网络的问题，随着 `worker` 数量的增加，其加速比会迅速的恶化，需要借助其他辅助技术。

由于某一个 `GPU` 需要接收其他所有 `GPU` 的梯度，并求平均以及 `broadcast` 回去，若 `GPU` 数量越大时，通信成本也就越高。其基本架构如下图所示。

![img](https://pic3.zhimg.com/80/v2-5f7d8bd968de3c6c7d3c16fbd091a736_720w.jpg)

而 `Uber` 的 `Horovod`，采用的 `RingAllReduce` 的计算方案，其特点是网络单次通信量不随着 `worker(GPU)` 的增加而增加，是一个恒定值。

在 `RingALll` 中，`GPU` 集群被组织成一个逻辑环，每个 `GPU` 只从左邻居接受数据、并发送数据给右邻居，即每次同步每个 `gpu` 只获得部分梯度更新，等一个完整的 `Ring` 完成，每个 `GPU` 都获得了完整的参数。

与 `TreeAllReduce` 不同，`RingAllreduce` 算法的每次通信成本是恒定的，与系统中 `gpu` 的数量无关，完全由系统中 `gpu` 之间最慢的连接决定。

其基本的结构和算法原理如下所示：

![img](https://pic3.zhimg.com/80/v2-493e9b088c9f65deb716a639b9c42356_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-0fe51b68ae24afe0fd4e504d6cc95004_720w.jpg)

如上图所示的结构，在 `5` 次迭代之后，所有的 `GPU` 更新为了值之和。

## Pytorch 分布式使用流程

## 基本概念

下面是分布式系统中常用的一些概念：

- **`group`**：

即进程组。默认情况下，只有一个组，一个 `job` 即为一个组，也即一个 `world`。

当需要进行更加精细的通信时，可以通过 `new_group` 接口，使用 `word` 的子集，创建新组，用于集体通信等。

- **`world size`** ：

表示全局进程个数。

- **`rank`**：

表示进程序号，用于进程间通讯，表征进程优先级。`rank = 0` 的主机为 `master` 节点。

- **`local_rank`**：

进程内，`GPU` 编号，非显式参数，由 `torch.distributed.launch` 内部指定。比方说， `rank = 3，local_rank = 0` 表示第 `3` 个进程内的第 `1` 块 `GPU`。

在forward阶段，当前GPU上的module会被复制到其他GPU上，输入数据则会被切分，分别传到不同的GPU上进行计算；在backward阶段，每个GPU上的梯度会被求和并传回当前GPU上，并更新参数。也就是复制module -> forward -> 计算loss -> backward -> 汇总gradients -> 更新参数 -> 复制module -> …的不断重复执行，示意图如下：
因为数据会被均分到不同的GPU上，所以要求batch_size大于GPU的数量。下面对DataParallel的forward函数做一个
------------------------------------------------
版权声明：本文为CSDN博主「ARYAD」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ARYAD/article/details/117919705

假设读入一个 batch 的数据，其大小为 [30, 5, 2]，假设采用三张 GPUs，其运行过程大致为：

[1] -dataloader 将模型放到主 GPU 上，一般为 cuda:0;

[2] - 把模型同步到 3 张 GPUs 上;

[3] - 将总输入 batch 的数据平分为 3 份，这里每一份大小为 [10, 5, 2]；

[4] - 依次分别作为每个副本模型的输入；

[5] - 每个副本模型分别独立进行前向计算，假设为 [4, 5, 2];

[6] - 从 3 个 GPUs 中收集分别计算后的结果，并按照次序拼接，即 [12, 5, 2]，计算 loss;

[7] - 更新梯度.

相当于，`DataParallel`的“并行计算”只存在于forward pass中，**梯度回传**以及模型参数的更新是在**一个GPU上**进行的。

`DataParallel`中，全程维护同一个optimizer，对各GPU上梯度进行求和，然后在主GPU进行参数更新，之后再将参数broadcast到其他GPU

## nn.DistributedDataParallel

`torch.distributed` 每个进程对应一个独立的训练过程(自己的optimizer，独立完成所有优化步骤)，且只对梯度等少量数据进行信息交换。各进程梯度计算完成之后，各进程将梯度进行汇总平均，然后再由`rank=0`的进程，将其`broadcast`到所有进程，之后各进程用该梯度来更新参数。



作者：Kloping
链接：https://www.jianshu.com/p/1025cfcd3a43
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

每个GPU只有一个进程，并且一个进程控制一个model。这些不同的GPUs可以在同一个机器或者不同的机器。它们之间的信息交流只有gradient。

训练过程中，每个进程都从硬盘中加载自己的mini-batch并将其传入GPU。

1. 每个GPU都独立完成forward pass，使用自己加载的mini-batch来计算损失函数的梯度。
2. 通过GPU间的通信计算梯度的平均值
3. back propagation，更新模型

注意，上述过程的第二第三步是同时进行的，也就是说，每到模型的一层layer，每个GPU先单独计算自己的gradient，然后所有GPU之间进行一次gradient平均值，然后大家一起回传同样的gradient到下一层layer。这样让每个GPU上的模型的权重更新保持一致。

其中第二步中，用到了*All Reduce*算法来计算多GPU之间的梯度均值。更多阅读资料在文末的Reference中

------

#### 模型并行 vs 数据并行

- 模型并行：不同的GPU输入相同的数据，运行模型的不同部分，比如多层网络的不同层。
- 数据并行：不同的GPU输入不同的数据，运行相同的完整的模型 `model = nn.DataParallel(model)`



作者：Kloping
链接：https://www.jianshu.com/p/1025cfcd3a43
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**缺点：**

- 在每个训练批次（batch）中，因为模型的权重都是在一个进程上先算出来，然后再把他们分发到每个GPU上，所以网络**通信**就成为了一个瓶颈，而GPU使用率也通常很低。
- 除此之外，nn.DataParallel 需要所有的GPU都在一个节点（一台机器）上，且并不支持 Apex 的 混合精度训练。

一句话，**一个进程算权重使通信成为瓶颈，**nn.DataParallel慢而且不支持混合精度训练。

Pytorch

[(54条消息) PyTorch中的model.modules(), model.children(), model.named_children(), model.parameters(), model.nam..._Serendipity0928的博客-CSDN博客_model.named_children()](https://blog.csdn.net/Pl_Sun/article/details/106978171)

## python generator

对gennerator取第一个 也可以用next

```
[i for i in model.named_parameters()][0]
```

对gnerator

![image-20220411235338028](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220411235338028.png)

传统的推荐方法主要包括协同过滤、基于内容的推荐方法和混合推荐方法。其中，最经典的算法是亚马逊2003年提出的协同过滤.算法。协同过滤利用用户与项目,之间的交互信息（如浏览历史记录等）为用户产生推荐，

[Amazon.com recommendations: item-to-item collaborative filtering](https://link.zhihu.com/?target=https%3A//ieeexplore.ieee.org/document/1167344)

也遭遇到了严重的数据稀疏(一个用户评分过的项目仅仅占总项目数量的极少部分）和冷启动（新的用户和新的项目往往没有评分数据）问题。

传统的浅层模型依赖于人工设计，其有效性及可扩展性非常有限，比如其无法学习到用户和项目交互的的深层次特征，同时也难以学习到网站中的多模态数据。（比如难以综合商品的图像和视频数据）



[Amazon.com recommendations: item-to-item collaborative filtering](https://link.zhihu.com/?target=https%3A//ieeexplore.ieee.org/document/1167344)



深度学习通过组合低层特征形成更加稠密的高层语义抽象，从而自动发现数据的分布，解决了传统机器学习中需要人工设计特征的问题，在图像识别、机器翻译、语音识别。

当前主流的深度学习技术例如RNN，GRU，包括最近火热的Transformer，序列推荐开始基于这些序列模型来建模，例如GRU4Rec，SASRec等，随着图神经网络的发展，基于GNN的方法也变得非常热门。



颗粒效果

**3、滤镜-滤镜库**

接下来，我们选中拷贝的文字图层，然后在【滤镜】中打开【滤镜库】。

![PS如何给文字添加胶片颗粒效果?PS给文字添加胶片颗粒效果教程](https://img.jbzj.com/file_images/photoshop/202109/2021092310304840.jpg)

**4、艺术效果-胶片颗粒，调整参数**

我们在【艺术效果】中点击【胶片颗粒】，把颗粒设置为【20】，高光区域为【20】，点击【确定】。

![PS如何给文字添加胶片颗粒效果?PS给文字添加胶片颗粒效果教程](https://img.jbzj.com/file_images/photoshop/202109/2021092310304841.jpg)

**5、图层模式设置为滤色**

我们把拷贝的NEW文字图层模式设置为【滤色】就完成了。

![PS如何给文字添加胶片颗粒效果?PS给文字添加胶片颗粒效果教程](https://img.jbzj.com/file_images/photoshop/202109/2021092310304842.jpg)

**6、更换颜色效果**

最后，如果我们需要更换颜色，选中下面一层的NEW文字图层，进行更换颜色即可（胶片颗粒的图层不需要调整）。

### Python Json文件的简单操作

```python
import pandas as pd
import json
data=pd.read_csv("../train.csv")
taxi_id=data["TAXI_ID"].value_counts().keys()#提取出TAXI——ID的种类
print(type(taxi_id))
taxi_id=taxi_id.astype(str)#转换数字为str
print(taxi_id)
taxi_id_dict=dict()
for index,id in enumerate(taxi_id):
    taxi_id_dict[id]=index#生成dict
print(taxi_id_dict)
with open('userID.json', "w") as f:
    f.write(json.dumps(taxi_id_dict))#dict转json然后用文件写
```





阿里云有一系列的操作l



![image-20220425113902038](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220425113902038.png)

## Python Time 用法 ：警告！划分时间有一个大坑！！！！！！！！！：就是时区问题

time和datetime的区别



[Python中time和datetime的区别 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/101939095)

```python
 get_off_t=datetime.datetime.utcfromtimestamp(get_off_time)
print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(get_off_time)),datetime.datetime.utcfromtimestamp(get_off_time))
 print(datetime.datetime.utcfromtimestamp(get_off_time).strftime("%Y%m%d %H:%M:%S"))
#前面utc（就是格尼林治时间）#这玩意的时区是0
    print(datetime.datetime.utcfromtimestamp(get_off_time).strftime("%Y-%m-%d %H:%M:%S"))
 
```



```python
import time
#时间戳转换为特定字符串
end_timeArray = time.localtime(end_time_stamp)
beg_day = time.strftime("%Y-%m-%d", beg_timeArray)
#休眠
time.sleep(XXX)
#时间戳转字符串
datetime.datetime.utcfromtimestamp(get_off_time).strftime("%Y%m%d %H:%M:%S")
struct_time=datetime.datetime.utcfromtimestamp(time_stamp)
print(struct_time.replace(hour=0, minute=0, second=0, microsecond=0).strftime("%Y%m%d:%H%M%S"))
#这个可以打印午夜时间
            struct_time=datetime.datetime.utcfromtimestamp(time_stamp)
#这个可以打印午夜时间
            print(struct_time.replace(hour=0, minute=0, second=0, microsecond=0).strftime("%Y%m%d:%H%M%S"))
            print(struct_time.strftime("%Y%m%d%H%M%S"))
 #这个可以获取时间戳和午夜时间相差的秒数
            print((struct_time-struct_time.replace(hour=0, minute=0, second=0, microsecond=0)).seconds)
#获取午夜到现在的秒数
import datetime
now = datetime.datetime.now()
midnight = now.replace(hour=0, minute=0, second=0, microsecond=0)
seconds = (now - midnight).seconds
或者

import datetime
now = datetime.datetime.now()
midnight = datetime.datetime.combine(now.date(), datetime.time())
seconds = (now - midnight).seconds
选择哪一个取决于品味。
```

Docker上有mysq

## PythonDGL包

```python
#警告
dgl只支持cuda11.3以及以下版本的cuda
```



## Python 一键生成requirements.txt

```python
pip install pipreqs
pipreqs ./ --encoding=utf8
```



## Python random用法



```python
random.random()用于生成一个0到1的随机符点数: 0 <= n < 1.0
```



## python基本语法

python多线程

相同的代码，为何有时候多线程会比单线程慢，有时又会比单线程快？ 这主要跟运行的代码有关：

#### CPU密集型代码(各种循环处理、计数等等 )，

在这种情况下，由于计算工作多， ticks计数很快就会达到 100阈值，然后触发 GIL的释放与再竞争 （多个线程来回切换当然是需要消耗资源的），所以 python下的多线程遇到 CPU密集型代码时，单线程比多线程效率高。

#### IO密集型代码 (文件处理、网络爬虫等 )，

多线程能够有效提升效率单线程下有 IO操作会进行 IO等待，造成不必要的时间浪费。开启多线程能在线程 A等待时，自动切换到线程 B，可以不浪费 CPU的资源，从而能提升程序执行效率 。进行IO密集型的时候可以进行分时切换 所有这个时候多线程快过单线程

### 生产者消费者多线程爬虫

生产者负责请求，消费者负责处理数据

![image-20220417203505957](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220417203505957.png)

```python
import queue
import random
import threading
import time


# 生产者
def do_craw(url_queue: queue.Queue, html_queue: queue.Queue):
    while True:
        u = url_queue.get()#生产原材料
        html_queue.put(blog_spider.craw(u))#放到中间商处
        print(threading.current_thread().name, f"craw {u}",
              'url_queue.qsize=', url_queue.qsize())
        time.sleep(random.randint(1, 2))
        

#消费者
def do_parse(html_queue: queue.Queue, fout):
    while True:
        h = html_queue.get()#从中间商处拿货
        results = blog_spider.parse(h)
        for result in results:#写入文件，注意其中fout是一个文件流
            fout.write(str(result) + '\n')
        print(threading.current_thread().name, f"results.size", len(results),
              'html_queue.qsize=', html_queue.qsize())
        time.sleep(random.randint(1, 2))


if __name__ == "__main__":
    url_queue = queue.Queue()#生产资料队列
    html_queue = queue.Queue()#中间商队列
    for u in blog_spider.urls:#生产资料加入生产资料队列
        url_queue.put(u)
    for idx in range(3):#开三个生产者线程
        t = threading.Thread(target=do_craw, args=(url_queue, html_queue), name=f'craw{idx}')#这个是标记进程号                #这个args是共享的变量
        t.start()

    fout = open(r'results.txt', 'w+', encoding='utf-8')
    for idx in range(2):#消费者线程
        t = threading.Thread(target=do_parse, args=(html_queue, fout), name=f'parse{idx}')#
        t.start()

```

python线程池函数

下面程序使用 map() 方法来启动 3 个线程（该程序的线程池包含 4 个线程，如果继续使用只包含两个线程的线程池，此时将有一个任务处于等待状态，必须等其中一个任务完成，线程空闲出来才会获得执行的机会），map() 方法的返回值将会收集每个线程任务的返回结果。

运行上面程序，同样可以看到 3 个线程并发执行的结果，最后通过 results 可以看到 3 个线程任务的返回结果。

通过上面程序可以看出，使用 map() 方法来启动线程，并收集线程的执行结果，不仅具有代码简单的优点，而且虽然程序会以并发方式来执行 action() 函数，但最后收集的 action() 函数的执行结果，依然与传入参数的结果保持一致。也就是说，上面 results 的第一个元素是 action(50) 的结果，第二个元素是 action(100) 的结果，第三个元素是 action(150) 的结果。

值得注意的是，queue队列是线程安全的，可以放心大胆的用

------------------------------------------------


```python
#线程池打印一
from concurrent.futures import ThreadPoolExecutor
import threading
import time
# 定义一个准备作为线程任务的函数
def action(max):
    my_sum = 0
    for i in range(max):
        print(threading.current_thread().name + '  ' + str(i))
        my_sum += i
    return my_sum
# 创建一个包含4条线程的线程池
with ThreadPoolExecutor(max_workers=4) as pool:
    # 使用线程执行map计算
    # 后面元组有3个元素，因此程序启动3条线程来执行action函数
    results = pool.map(action, (50, 100, 150)) #这个是一下子全部提交
    print('--------------')
    for r in results:
        print(r)        
# time.sleep(0.1) # 休眠0.1秒

#使用线程池作为爬虫
#使用线程池作为爬虫
import concurrent.futures
import urllib.request

URLS = ['http://www.github.com',
        'http://www.foxnews.com/',
        'http://www.cnn.com/',
        'http://www.baidu.com/',
        'http://www.google.com/',
        'http://www.zhihu.com/']
#ps 国内就能上fox和cnn
# Retrieve a single page and report the URL and contents
from concurrent.futures import ThreadPoolExecutor
import threading
import time
def load_url(url, timeout):
    with urllib.request.urlopen(url, timeout=timeout) as conn:
        return conn.read()

# We can use a with statement to ensure threads are cleaned up promptly
#使用with可以确保线程池被清理干净
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Start the load operations and mark each future with its URL 注意mark
    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
#这里的loadurl是不同的，但是
    for future in concurrent.futures.as_completed(future_to_url):
        #这里的future是一种异步的能够遍历已经完成thread的东东
        url = future_to_url[future]
        try:
            data = future.result()
        except Exception as exc:
            print('%r generated an exception: %s' % (url, exc))
        else:
            print('%r page is %d bytes' % (url, len(data)))
          
 #使用线程池作为爬虫
import concurrent.futures
import urllib.request
import queue
import random
# URLS = ['http://www.google.com/',
#         'http://www.baidu.com/',
#         'http://www.github.com',
#         'http://www.foxnews.com/',
#         'http://www.cnn.com/',
#         'http://www.luogu.com/',
#         'http://www.zhihu.com/']
URLS = ['http://www.google.com/',
        'http://www.baidu.com/',
]
url_queue=queue.Queue()
for url in URLS:
    url_queue.put(url)
#ps 国内就能上fox和cnn
# Retrieve a single page and report the URL and contents
from concurrent.futures import ThreadPoolExecutor
import threading
import time
def load_url(url_queue:queue.Queue, timeout,idx:int):
    print(idx,"start")
    emptylist=[]
    while not url_queue.empty():
        url=url_queue.get()
        print(idx,url)
        with urllib.request.urlopen(url, timeout=timeout) as conn:
            if url=='http://www.google.com/':
                url_queue.put('http://www.gitee.com/')
                print(idx,"add")
            # time.sleep(2)
            # return conn.read()
            emptylist.append([url,conn.read()])
        time.sleep(random.random())
    print(idx,"end")
    return emptylist
# We can use a with statement to ensure threads are cleaned up promptly
#使用with可以确保线程池被清理干净
with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
    # Start the load operations and mark each future with its URL
    # Start the load operations and mark each future with its URL
    future_to_url={executor.submit(load_url,url_queue,60,idx):idx for idx in range(0,4)}
    for future in concurrent.futures.as_completed(future_to_url):
        idx = future_to_url[future]
        poi_result_list=future.result()
        for url_response in poi_result_list:
            try:
                data = url_response[1]
            except Exception as exc:
                print('%r generated an exception: %s' % (url_response[0], exc))
            else:
                print('%r is %d bytes' % (url_response[0], len(data)))
```

future object

[concurrent.futures — Launching parallel tasks — Python 3.10.4 documentation](https://docs.python.org/3/library/concurrent.futures.html?highlight=threadpoolexecutor#concurrent.futures.ThreadPoolExecutor)



系统级别操作

```bash
#终止程序操作
sys.exit(0)
```





### Python 传值传址

[深入理解python中函数传递参数是值传递还是引用传递_python_脚本之家 (jb51.net)](https://www.jb51.net/article/127667.htm)



### 切片

```
>>> s = "abcdefg"
>>> print(s[:])
abcdefg
>>> print(s[0:4])
abcd
>>> print(s[2:6])
cdef
>>> print(s[:6:2])
ace
>>> print(s[1::2])
bdf
>>> print(s[::-1])
gfedcba
>>> print(s[-1:-3])

>>> print(s[-1:-3:-1])
gf
>>> print(s[-1::-2])
geca
```



## 字符相关操作

常见字符串操作比较牛逼的操作

[(45条消息) Python 字符串的常用操作_IT_狂奔者的博客-CSDN博客_python字符串的基本操作](https://blog.csdn.net/chj_1224365967/article/details/112021364?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.1&utm_relevant_index=3)

常见字符串拼接操作

[8种Python字符串拼接的方法，你知道几种？ - Python探索牛 - 博客园 (cnblogs.com)](https://www.cnblogs.com/djdjdj123/p/15449510.html)

总之在python中不建议使用“+”（性能低下）

建议使用

```
''.join(某个列表)
```

### Sring操作

`%s`占位符 or format连接

```python
text1 = "Hello"
text2 = "Hider"
print("%s%s" % (text1, text2)) # 'HelloHider'
#使用 format 格式化字符串也可以进行拼接。
print("{0}{1}".format(text1, text2)) # 'HelloHider'

str(poi_code).endswith("0000")#判断末尾

#判断字符是否全部相等
==
#判断字符串地址是否相等
af="ff.txt"
a=af.split('.')[0]
b='ff'
a is b
False
```

```

```

```python

```



### 遍历a-z|列表/元祖内for循环

2行代码就能打印出:A-Z

```python

# -*- coding:UTF-8 -*-
li = [chr(i) for i in range(ord("A"),ord("Z")+1)]

#ord函数将字符转换为整数显示，chr将整数转换为字符显示
#带索引的循环
for i, n in enumerate(numbers):
    print(i, n)
print(li)
```

分析：

ord函数将字符转换为整数显示，chr函数将整数转换为字符显示

但是你如果要做字母表的话建议直接用减号

https://leetcode-cn.com/problems/unique-morse-code-words/solution/

### /python列表循环

```python
MORSE = [".-", "-...", "-.-.", "-..", ".", "..-.", "--.",
         "....", "..", ".---", "-.-", ".-..", "--", "-.",
         "---", ".--.", "--.-", ".-.", "...", "-", "..-",
         "...-", ".--", "-..-", "-.--", "--.."]

class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        return len(set("".join(MORSE[ord(ch) - ord('a')] for ch in word) for word in words))
```

### python 普通循环

#### range

**range 对象是不可变的等差序列。可以用iter(range(X))转为迭代对象**

### 函数语法

```
range(start, stop[, step])
```



参数说明：

- start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;
- stop: 计数到 stop 结束，**但不包括 stop**。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5
- step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)

range(0, -10, -1) 

负数 [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]

### Dict的兄弟set

主要用于

1 列表或者元祖去重

2 交集并集等相关操作

```python
enumerate函数
用了生成容器的下标函数
for index,value in enumerate(list/元祖/字符串)：

#注意他不是两个数组
#这玩意对pandas的series也起作用value_series.keys()

#列表去重
set（列表）
#添加
XX.add(某个元素)
#是否在里面
in set/
not in set
```

![image-20220417142004996](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220417142004996.png)

### Dict

```python
#生成dict
a_dict={'a':1,'b',"nihao"}

#注意dict的keys()不属于list
#要
list(my_dict.keys())
for word in words:
    if len(word) == 1:  # 单个词语不计算在内
        continue
    else:
        counts[word] = counts.get(word, 0) + 1  # 遍历所有词语，每出现一次其
id2name['P'+str(id_name[0])]=id_name[1]
#添加元素，有则改之，无则加之
        对应的值加 1
```

其中get第二个参数的意思是在找不到前面那个数的时候赋予的初始值

### 根据两个列表生成dict

```python
#两个list装换成dict
a=dict(zip(list1,list2))
#判断是否为字母
s[i].isalnum()
#转换 pandas - dict 
df1 = df.set_index(['name'])['age'].to_dict()
#求大小
len(XXX)
#值
print(entity_name_id.values())
#键值
print(entity_name_id.keys())
#items
```

## Python数据处理

### Pandas is in 的用法

[pandas is in和not in的使用说明_python_脚本之家 (jb51.net)](https://www.jb51.net/article/206924.htm)

### Python 加速（）

[提速百倍的Pandas性能优化方法，让你的Pandas飞起来！ - 知乎 (zhihu.com)]( 

pandas

### python中生成器类generator

https://www.cnblogs.com/zywscq/p/5774567.html

https://www.cnblogs.com/hiwuchong/p/8060266.html

## numpy

[(35条消息) 如何获取NumPy数组中N个最大值的索引？_asdfgh0077的博客-CSDN博客_numpy返回最大值索引](

```python
data_npy=data_npy.tolist()#python转list
np.save("yingjian.npy",data_npy)#存npy
with open("../time_locate_div_day/div_by_day/{0}.txt".format(day), "ab") as f:
	np.savetxt(f, numpy_data,fmt="%s")
```

```python
np.zeros((city_units.shape[0],len(id2name)))
#注意zeros的第一个餐食是一个()包裹的二维的东西
```



## pandas

pandas的使用哲学：缓慢增长（X）并行操作（Y）

[python pandas 怎样高效地添加一行数据？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/36170252)

```python
#效率低
for 
	df.append()
#效率高
#比如在某个地方，你想通过一个循环统计某些东西，最好的方式是通过list[dict1,dict2.....]生成相应的dataframe
rows_list = []
for row in rows:
    rows_dict = {}
    rows_dict.update(row)
    rows_list.append(rows_dict)
df = pd.DataFrame(rows_list)

#pandas统计出现次数
df[col_name].value_counts()
#df.drop([‘name1’,‘name2’],axis=1,inplace=True)
# print(cur_data)
```

## Numpy

```python

cur_data.to_numpy()
np.savetxt(f, numpy_data,fmt="%s")

```

### pandas排序

```python
# 对两列同时按照升序排列
shop.sort_values(by=['worthy', 'price'], inplace=True, ascending=True)
print(shop)

```



### pandas基本使用

### pandas添加行操作

```python
for _,row in new_data.iterrows():
    initial.loc[initial.shape[0]]={"X":row["POINT_X"],"Y":row["POINT_Y"]}
#添加行，如果为空则为NaN
```

```python


csv_list=[]#典型例子讲解
for file_name in os.listdir("poi_dfs_text_csv"):#列出问题目录
    if file_name.endswith(".csv"):
        csv_list.append(file_name)
if __name__ == "__main__":
    unit = pd.read_csv('city_unit.csv')
    
    #警告如果加入参数 header=None 则默认首行就是数据
    data=pd.read_csv(r"csv_div_by_day/2013-07-01.csv",header=None)
    unit.drop(columns=["Unnamed: 0", "FID"], inplace=True)
    for file_name in csv_list:
        poi = pd.read_csv('poi_dfs_text_csv/259.csv')
        unit["P6"] = 0
        count_empty = 0
        for row in poi.itertuples():
            y = row[2]  # lat
            x = row[3]  # long
            line = unit.loc[
                (unit['POINT_X'] > x - 0.003) & (unit['POINT_X'] <= x + 0.003) & (unit['POINT_Y'] > y - 0.003) & (
                            unit['POINT_Y'] <= y + 0.003)]
            print(line, line.empty)
            if line.empty:
                count_empty += 1
            else:
                # print(line.index[0],"原来是浮点数")
                unit.loc[line.index[0],'P6']+=1
        print(unit["P6"].describe())
        unit.to_csv("test_result.csv")

```



[pandas.DataFrame.insert — pandas 1.4.2 documentation (pydata.org)](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.insert.html?highlight=insert#pandas.DataFrame.insert)

```python
# dataframe 新建
df2 = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), columns=['a', 'b', 'c'],)

#清空 原地 保留表头

print(unit_for_search.drop(columns='fk'))#删除特定列
 data = data.dropna(axis=0, subset=["ID_STAMP_12"])  
#删除某行值为0，先求出值为0所在行的索引，然后根据索引行删除
df.drop( index = df.age[df1.age == 0].index )
#当[ID——stamp]为空的时候丢弃那一行,还有how参数how=“all”/"any"

#pandas 转换为numpy
cur_data.to_numpy()
#行数
pd.shape[0]
#统计这一行出现的词的个数
#类似字典
value_series=data['BEG_DAY'].value_counts()
#索引
for index,value in enumerate(value_series.keys()):
      day_dict[value]=index
enumerate(value_series.keys()):

df.drop(df.index, inplace=True)
#删除索引
df=df.drop(index=df.index)

road.empty#判空
print(entity_types.shape[0])#查看多少列
print(entity_types.columns)#打印列名
#loc iloc

#关于多条件筛选的一篇很好的博客
https://zhuanlan.zhihu.com/p/286682789
    
XX.loc[[]]
df.loc['viper']#定位列
df.loc[['viper', 'sidewinder']]#定位行和列
#选取这几列
cur_data.loc[:,["TRIP_ID","TAXI_ID","ID_STAMP_12","SPAN_DAY"]]
cur_data=data.loc[(data['BEG_DAY']==day)]#按照值筛选
road=poi_code.loc[lambda row: (row.X>x-0.0030000001) & (row.X<x+0.0030000001)&(row.Y>y-0.0030000001)& (row.Y<y+0.0030000001)]# lambda筛选出结果
#iloc iloc iloc iloc iloc
road.iloc[0,0]#序列定位
df.iloc[[0]]#行
print(entity_types.iloc[:,[1]])#获取第二列的所有数据
print(entity_types.iloc[:,[0]])#获取第一列的所有数据
print(df.iloc[:, :2])#获取所有所有行*前2列的数据

poi_statistics.loc[road, "P" + new_typecode]+=1#定位累加
#This is usually the result of calling `frame.insert` many times, which has poor performance.如果要插入大量的列不建议用insert！
'''
https://stackoverflow.com/questions/68292862/performancewarning-dataframe-is-highly-fragmented-this-is-usually-the-result-o '''\
# 建议用如下的命令2333
poi_statics=pd.DataFrame(columns=entity_name_id.values())
poi_units=pd.concat([city_units,poi_statics],axis=1)

 pd.concat((df1,df),axis=0)
poi_statistics.insert(poi_statistics.shape[1], big_code, 0)#添加列名 
big_code 同时其初始值为0
poi_statistics.insert(poi_statistics.shape[0], big_code, 0)#添加行名 
 poi[["typecode"]] = poi[["typecode"]].astype(str)#转换列为str
    
    
for r in zip(poi['typecode'],poi['roadid'])#高效遍历 列（无法获得索引)
for ir in df.itertuples():
    list1.append((ir[1], ir[2])) #中效遍历，其中索引的第一行为索引的序列
    
 poi_units.loc[row[0],name] #比如这个就能定位某行某列
#文件操作python基础
for i in  os.listdir(r'D:\amyprocess\get_poi\final_result\当前的所有数据_按照中类进行分类\one_xlsx\output/'):
列出所有文件
#转换操作
#两列转dict
df1 = df.set_index(['name'])['age'].to_dict()
dc = df.set_index("A")["B"].to_dict()

#文件操作
poi_statistics.to_csv("test_.csv")
poi_code = pd.read_excel(r"amap_poicode.xlsx",keep_default_na=False)
poi_statistics=pd.read_excel(r"SE.xlsx")
#设置分隔符
unit_for_search=pd.read_csv('merge_unit.csv',sep=' ')
print(unit_for_search.columns)

```

![image-20220312190035976](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220312190035976.png)

#### pandas 如果列名为整数，会有一系列bug 所以要小心

比如某列名字为0100000

[当列名为整数时，按列号索引pandas数据帧 - 问答 - Python中文网 (cnpython.com)](https://www.cnpython.com/qa/48671)

#### **pandas在表格中读取列表或者时间默认为字符串问题**|字符串转list

### ast包可以用于转换str与list

```python
import ast
df["col"] = df["col"].apply(ast.literal_eval)
data["ID_STAMP_12"]=data["ID_STAMP_12"].apply(ast.literal_eval)
亲测可以处理多维列表，还能智能标识数据类型(int/float)
#按照行遍历添加
poi['roadid'] = poi.apply(lambda x: getRoadID(x.wgs84_lon, x.wgs84_lat), axis = 1)
```

如果要在pandas中存入列表之类的类型，pandas默认为object的类型

![image-20220323163253334](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220323163253334.png)

![image-20220323163348840](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220323163348840.png)

你最后读出来pandas都会默认处理成string类型

所以你在读取的时候需要将string类型转换成list

转换方式如下

[(41条消息) 用dataframe格式存储列表，再读取列表时如何将字符串转化为列表_kerreny的博客-CSDN博客_dataframe 存储list](https://blog.csdn.net/weixin_45414380/article/details/104263610?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)

[(41条消息) eval和ast.literal_eval方法_阿慕路泽的博客-CSDN博客_ast literal_eval](https://blog.csdn.net/sinat_33924041/article/details/88350569)

一种更加安全的形式

### 按照行遍历的方法

[(41条消息) 在pandas中遍历DataFrame行_ls13552912394的博客-CSDN博客_dataframe遍历每一行](https://blog.csdn.net/ls13552912394/article/details/79349809)



```python
for index, row in df.iterrows():
    print(index) # 输出每行的索引值
```

定位

[pandas DataFrame的查询方法（loc,iloc,at,iat,ix的用法和区别） - 蒙面的普罗米修斯 - 博客园 (cnblogs.com)](https://www.cnblogs.com/datasnail/p/9757081.html)



pandas 运算

[(41条消息) 数据分析之Pandas（四）DataFrame运算_提莫君的博客-CSDN博客_dataframe 运算](https://blog.csdn.net/qq_42642945/article/details/88636151?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2)

```python
#加减乘除
DataFrame.add(other, axis=’columns’, level=None, fill_value=None)
DataFrame.sub(other, axis=’columns’, level=None, fill_value=None)
DataFrame.mul(other, axis=’columns’, level=None, fill_value=None)
DataFrame.div(other, axis=’columns’, level=None, fill_value=None)
```

参数:
other : 序列, 数据框, 常量
axis : {0, 1, ‘index’, ‘columns’}0和index是横向运算,1和columns是纵向运算
fill_value : None或者浮点型,替换缺省值
level : int或name,选择不同的索引,一个数据框可能有两个索引
返回值:
数据框

```python
import pandas as pd
df = pd.DataFrame([[1,1,1],[2,2,2],[3,3,3]],columns=['A', 'B', 'C'])
print(df)
   A  B  C
0  1  1  1
1  2  2  2
2  3  3  3
print(df.sub([1,2,3],axis=1))
   A  B  C
0  0 -1 -2
1  1  0 -1
2  2  1  0
print(df.sub([1,2,3],axis=0))
   A  B  C
0  0  0  0
1  0  0  0
```

Pandas遍历行

pandas 遍历有以下三种访法。 


iterrows（）：在单独的变量中返回索引和行项目，但显着较慢 
itertuples（）：快于.iterrows（），但将索引与行项目一起返回，ir [0]是索引 
zip：最快，但不能访问该行的索引 
df= pd.DataFrame({'a': range(0, 10000), 'b': range(10000, 20000)})






0.for i in df:并不是遍历行的方式
for i in df:
    print(i)




 正式因为for in df不是直接遍历行的方式所以我们研究了如下方法。

1.iterrows（）：在单独的变量中返回索引和行项目，但显着较慢 
df.iterrows()其实返回也是一个tuple=>(索引，Series)
count=0
for i,r in df.iterrows():
    print(i,'-->',r,type(r))
    count+=1
    if count>5:
        break




 2.itertuples（）：快于.iterrows（），但将索引与行项目一起返回，ir [0]是索引
count=0
for tup in df.itertuples():
    print(tup[0],'-->',tup[1::],type(tup[1:]))
    count+=1
    if count>5:
        break




 3.zip：最快，但不能访问该行的索引
count=0
for tup in zip(df['a'], df['b']):
    print(tup,type(tup[1:]))
    count+=1
    if count>5:
        break 




 4.性能比较

复制代码

```python
df = pd.DataFrame({'a': range(0, 10000), 'b': range(10000, 20000)})
import time
list1 = []
start = time.time()
for i,r in df.iterrows():
    list1.append((r['a'], r['b']))
print("iterrows耗时  :",time.time()-start)

list1 = []
start = time.time()
for ir in df.itertuples():
    list1.append((ir[1], ir[2]))    
print("itertuples耗时:",time.time()-start)

list1 = []
start = time.time()
for r in zip(df['a'], df['b']):
    list1.append((r[0], r[1]))
print("zip耗时       :",time.time()-start)
```

复制代码

## Leetcode和基本算法

python 中翻转字符串就用到这个题 s+s拼接

## KMP

![](https://pic1.zhimg.com/v2-f29d822e4faf22542875de6c73fe07d0_b.webp)

![](https://pic1.zhimg.com/v2-e66f7a92145c8e3ea8c87b5889fbaf54_b.webp)

## Leetcode

### 树

最高度小树

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。

请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。
树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。

 ![image-20220406090439111](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220406090439111.png)

示例 1：

输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。

示例 2：

输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
输出：[3,4]

 

提示：

    1 <= n <= 2 * 104
    edges.length == n - 1
    0 <= ai, bi < n
    ai != bi
    所有 (ai, bi) 互不相同
    给定的输入 保证 是一棵树，并且 不会有重复的边



思路：ps 

```python
#不要试图在树的儿子中获取父亲的全部信息
#善于利用无限的思想
#如果给的是边的集合，要从连通集的角度去理解
```



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-height-trees
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 齐哥的笔记相当不错，建议记一记

## 规范问题



```c++
1.不要使用n和m a或者b 统一使用"line"和"col"
2.不要使用ture==atlas[x][y]，因为true只有1，但是atlas可以为非零，如果atlas为int类型，记得使用不等于0等标识！！！！！！！！
3.手动换行模式为
    if(y==col+1){
        if(x==line){
            //结束处理
            return;
        }
       x=line+1;
       y=1;
    }
4.记得加dx和dy！！！！
    for(int i=0;i<5;i++){
        atlas[x+dx[i]][y+dy[i]];
    }
5.自己编的数据一定要对！！

```

```

```

## 分支限界法概念详解

原理

![image-20211110183648628](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110183648628.png)

“限界原理”

若某孩子结点的目标函数值超出目标函数的界，则将该 孩子结点丢弃；否则，将该孩子结点保存在待处理结点表 PT中。从表PT中选取使目标函数取得极大值的结点作为下 一次扩展的根结点，重复上述过程。

### 伪代码

找一个value最大的解

![image-20211110184010226](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110184010226.png)

分支限界法的一般过程
1.根据限界函数确定目标函数的界down,upl;
2.将待处理结点表PT初始化为空；
3.对**根结点**的每个孩子结点x执行下列操作
	3.1估算结点x的目标函数值 value;
	3.2若( value>=down),则将结点x加入表PT中；
4.循环直到某个叶子结点的目标函数值在表PT中最大
	4.1**ⅰ表PT中值最大的结点；**
	4.2 对结点i的每个孩子结点x执行下列操作
	4.2.1估算结点x的目标函数值 value;**（往大了估值，估计这条路的最牛逼情况)**
		4.2.2若( value>=down),则将结点x加入表PT中；**（这条路可能比已知的可行解好的话）**
		4.2.3若**(结点x是叶子结点且结点x的 value值在表PT中最大，一个可行解比所有虚张声势的人都nb)，**
		则将结点x对应的解输出，算法结東；
		4.2.4若(**结点x是叶子结点但结点x的 value值在表PT中不是最		大)**，则令down= value,并且将表PT中所有小于 value的结点删除；

### 只求最优值

ub是上界的意思 up_bound

![image-20211110184534296](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110184534296.png)

![image-20211110184831636](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110184831636.png)



![image-20211110185125501](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110185125501.png)

### 求最优解的各个分量

![image-20211110185313429](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110185313429.png)

![image-20211110185724852](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110185724852.png)

### 时间复杂度

![image-20211110185344865](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110185344865.png)

指数！指数！！

### int 和double相加导致的数值损失

sum+=a[i]

如果sum是int类型的 a[i]是double类型的，相加时会把小数部分舍弃掉。

### 明确计数器的含义

### **求第二小值的模板**

if (min_2[i][1] > matrix[i][j]) {//3 1  5  5  3 1
				min_2[i][2] = min_2[i][1];
				min_2[i][1] = matrix[i][j];
			}
			else {
				if (min_2[i][2] > matrix[i][j]) {
					min_2[i][2] = matrix[i][j];
				}
			}

### top和pop尽量为原子语句

比如你把if放到中间会造成死循环

```c++
	Node now = PT.top();
	PT.pop();
	if (now.value > up) {
		continue;
	}
```

### Overlop问题可以用flag[__MaX__]计数器

```
12
 23
  35
   54
```

### 有时候预先排序效果也不错

```
比如对于有多个分支判断的情况
```

## 位运算的奇技淫巧

### swap的坑

### 判断奇偶

### n&（n-1）消去二进制中的一个1；(对正数有效)

某个数是否为2的次幂

判断2进制中有多少个1

https://www.zhihu.com/question/38206659

```c++
警告！！！这个程序千万别再日常中使用，因为如果a和b如果是一个指针，比如交换a[i]和a[j]当i==j时结果必定为0
0010
^ 0010
1 :0000
2: 0000
3: 0000
void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
}
判断奇偶（对0有效）
if(0 == (a & 1)) {
 //偶数
}
有用：在O（1）的时间内判断某个数是否为2的次幂
    (n&(n-1))==0
n   1010000
n-1 1001111
&   1000000
每次这样运算n就会少一个1，但是注意0&(0-1)[]
bool judge(int num) {
  return bool(n>0&&((n&(n-1))==0)
}
有用：判断二进制中1的个数
count = 0  
while(a){  
  a = a & (a - 1);  
  count++;  
}  
```

6.找到二进制中1出现的最低位（神仙算法）

(1000  》0001+1=0010)8

补码等于取反加一

```c++
a&-a   //也就是lowbit函数，树状数组要用
```

8.二进制进行子集枚举

使用一个正整数二进制，第i位是1还是0代表集合的第i个数取或者不取。所以从0到2^n-1总共2^n个整数，正好对应集合的2^n个子集。对此进行拓展有下列操作：

1）要求集合中不能有两个相邻的元素

```c++
if ((mask >> 1) & mask) continue;
```

2）在限定必须不取某些元素的前提下枚举子集

```c
// mask的第x位为0表示x必须不在子集中(原集合中不含这个元素)
for (int mask1 = mask; mask1 >= 0; mask1 = (mask1 - 1) & mask) 
```

3）在限定必须取某些元素的前提下枚举子集

```c
// mask的第x位为1表示x必须在子集中
for (int mask1 = mask; mask1 < (1 << m); mask1 = (mask1 + 1) | mask)
```

其他方法

利用a^ b ^b=a

1）数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数

数组中所有数依次异或，最后结果即为答案

2）数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的

假设这两个数分别是x和y.将数组全部异或，最终结果res=x^y。因为x!=y，res!=0。查看res，找出其二进制某一位为1，该位即为a。根据数组中每个数的a位是否为1可分为两组，采用1）中的方法分别求出两组的结果即可。

## 地图题中记录轨迹的方法

节点（比如分支界限）

### 建议使用stirng类型记录（传值和传参比较方便）

原点在左上（一般情况）

| 移动 | dx   | dy   | 哈希=dx*2+dy+2 |      |
| ---- | ---- | ---- | -------------- | ---- |
| 右   | 0    | 1    | 3              |      |
| 左   | 0    | -1   | 1              |      |
| 下   | 1    | 0    | 4              |      |
| 上   | -1   | 0    | 0              |      |
| 不动 | 0    | 0    | 2              |      |

上左右下

```C++
int dx[4]=  {0,0,1,-1};
int dy[4] = {1,-1,0,0};
string move_direction[5] = { "上","左","不动","右","下"};

轨迹记录
child.Route = now.Route + "-" + move_direction[2*dx[i]+dy[i]+2];//使用映射关系记录轨迹
```

其他 位运算|队列|栈。。。。



## 二分法

## 中位数法找坐标居中点

代浩然的中位数法其实是可以的，中位数一个数连接数组中所有数的总距离最小的整数点

就是 比如 

1  100  10000000000000000000 中位数1000才能两点一线

-100 2 3 3 3 

中位数为3 重叠只有二

如果选取2 重叠则为3

逆序对数

### 归并排序

在排序的过程中加上计算逆序数的过程

3 7 10 14 18 19|||| 2 11  16 17 23 25

合并**2** 3 7 10 **11** 14 16  17 18

逆序6 6 6  6   6   6 

![image-20211118091428538](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211118091428538.png)

注意移动11时，由于2已经被移走了所以逆序对也会变化

逆序对总之就是左边比我小的人数



## 二分法时间复杂度

二分法会退化的情况

即中轴法不一定是“对半分”的情况

对一个有序数组的二分查找，最差时间复杂度也为O（nlogn）

对快排，最差情况下时间复杂度为O（n^2）

### 快排时间复杂度的计算、

快排最好时间复杂度为O（nlogn）
快排最差时间复杂度为O（n^2）

![image-20211229223606035](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229223606035.png)

### 快排方式一和方式二划分是一样的，不过方式一好实现，面试一般是方式2

#### 实现快排的方式一：以第一个为中轴暂存，i比它大a[j]=a[i],j比它小 a[i]=a[j](记得最后复原)

1 3 4 5

快排在算法实现时最重要的是”空出“思想！！！！![image-20211118175857174](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211118175857174.png)

 假设中段为tmp为第一个数，暂存

如果j比中段小，i的位置存他

如果i比中段大，j的位置存他

如果i==j，中段存arr【i】

核心思想是左边的都是比中段小的数，有右边的是比中段大的数

快排就是双指针边交换边找中轴->递归找两边的两段的情况->递归算

### 实现快排的方式二：swap（老师用的是这种），好理解

![image-20211229222204151](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229222204151.png)

### 最大子段和（李朝辉之前的研究生面试题）

最大字段和用贪心应该只要O(n)的时间复杂度

用贪心的解法

如果当前这个数是负数

​	如果加上他之后的和根本不划算<0,扔掉（sum=0）

​	如果加上他之后的和还行>0,姑且加上他

否则

​	加上这个数，如果sum==0 ，则刚刚开始扔掉之前的

每轮最后检查本轮sum是否大于以前最大值

1 -2 4  5 4





### 股票问题

假如你正在为一投资公司咨询。他们正在做模拟，对一给定的股票连续观察n天，记为i=1,2,,n;对每天，该股票每股的价格p（i）。假设在这个时间区间内，在某一天他们想买1000(第i天)股而在另一天（第天）卖出所有这些股。为得到最多收益，他们应什么时候买什么时候卖？请设计算法在O( nlogn)时找到正确的i与j

![image-20211118100607735](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211118100607735.png)



### 二维空间最短点问题

![image-20211118195729406](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211118195729406.png)

还记得校赛中的最短二维问题是用DFS解决的大二 校赛



一般来说二维空间中的最近的点即集是





## 贪心和动态规划

### 如何区分动态规划和贪心

贪心的特点-一维数组，数值固定，不会有二元组，以这道题为例子，他只有加油站之间的距离，每次加油必须加满，行驶里程恒定

贪心策略，选取当前油量所能到达的最远加油站

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211209103823545.png" alt="image-20211209103823545" style="zoom:50%;" />

如果是油箱无限，但是加油站所能提供的油量有限，则使用动态规划，比如下面的广告牌价值问题

注意他有x和r两个数组二期还有距离限制

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211209104212143.png" alt="image-20211209104212143" style="zoom:50%;" />



假设你正在管理一条公路的广告牌建设，这条路从西到东M英里。广告牌可能的地点假设为x1,x2,x3…xn，处于[0,M]中。若在xi放一块广告牌，可以得到ri>0的收益。国家公路局规定，两块广告牌相对不能小于或等于5英里之内。如何找一组地点使你的总收益达到最大？
例如假设M=20, n=4, {x1,x2,x3,x4}={6,7,12,14} 且｛r1,r2,r3,r4}={5,6,5,1} ，则

20 4

6 7 12 14

5 6 5 1



## 二维动态规划



<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211209130048677.png" alt="image-20211209130048677" style="zoom:50%;" />



------------------------------------------------
这道题就是用的是基于广搜的动态规划，用

```c++
fee[x][y][z]代表到达x，y时，剩余z油量所需要的花费
    
```

对三种情况动归

1 开车（广搜）

2 加油

3 建立油站

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int _MAX_NUM = 10000;
int fee[110][110][15], init[110][110][15];
int n, full_k, a, b, c, ma[110][110];
struct node
{
    int x, y, k;
};
queue<node> q;
int dx[4] = { -1,0,1,0 };
int dy[4] = { 0,1,0,-1 };
int main()
{
    cin >> n >> full_k >> a >> b >> c;//加油费用 b倒着走费用
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            cin >> ma[i][j]; 
    memset(fee, 20, sizeof(fee));
    fee[1][1][full_k] = 0;
    init[1][1][full_k] = 1;
    q.push({ 1, 1, full_k });
    while (!q.empty())//费用
    {
        int X = q.front().x;
        int Y = q.front().y;
        int K = q.front().k; 
        q.pop();
        cout<<"("<<X<<","<<Y<<""<<" :"<<K<<"   "<<fee[X][Y][K]<<endl;
        init[X][Y][K] = 0;
        if (ma[X][Y] && K != full_k)//加油 
        {
            if (fee[X][Y][full_k] > fee[X][Y][K] + a)//记录加满油的开销剩下的油量
            {//不足以加油费用
                fee[X][Y][full_k] = fee[X][Y][K] + a;
                if (!init[X][Y][full_k]) {
                    init[X][Y][full_k] = 1;
                    q.push({ X, Y, full_k });
                }
            }
            continue;
        }
        else
        {//油库
            if (fee[X][Y][full_k] > fee[X][Y][K] + a + c)//记录加满油+建立油站的开销
            {
                fee[X][Y][full_k] = fee[X][Y][K] + a + c;
                if (!init[X][Y][full_k]) {
                    init[X][Y][full_k] = 1;
                    q.push({ X, Y, full_k });
                }
            }
        }
        if (K > 0)//开车 
            for (int i = 0; i < 4; ++i)//向四个方向扩散
            {
                int x = X + dx[i];
                int y = Y + dy[i];
                if (x<1 || x>n || y<1 || y>n)
                    continue;
                int len = 0;
                if (x < X || y < Y)
                    len = b;
                if (fee[x][y][K - 1] > fee[X][Y][K] + len)、
                {
                    fee[x][y][K - 1] = fee[X][Y][K] + len;
                    if (!init[x][y][K - 1]) {
                        init[x][y][K - 1] = 1; 
                        q.push({ x, y, K - 1 });//加油
                    }
                }
            }
    }
    int ans = _MAX_NUM;
    for (int i = 0; i <= full_k; ++i)
        ans = min(ans, fee[n][n][i]);
    printf("%d\n", ans);
    return 0;
}
/*
9 3 2 3 6
0 0 0 0 1 0 0 0 0
0 0 0 1 0 1 1 0 0
1 0 1 0 0 0 0 1 0
0 0 0 0 0 1 0 0 1
1 0 0 1 0 0 1 0 0
0 1 0 0 0 0 0 1 0
0 0 0 0 1 0 0 0 1
1 0 0 1 0 0 0 1 0
0 1 0 0 0 0 0 0 0
*/
```



### 动态规划

## bug类型：粗心

### 输入输出bug，bug用时30min

简单bug 却花了长时间

千万不要简单复制，读入的时候的逻辑千万要注意

比如 w1 r1

和 w1 w2 w3 w4这种



### 比赛

# 题目一（对称字符串：动态规划）

## 题目描述

绿绿有一个由小写字母组成的非空字符串 R，但 Yazid 不知道它具体是什么。

我们定义翻转的操作：把一个串以最后一个字符作对称轴进行翻转复制。形式化地描述就是，如果他翻转的串为 R，那么他会将前 |R|−1 个字符倒序排列后，插入到串的最后。

举例而言，串abcd进行翻转操作后，将得到abcdcba；串qw连续进行 2 次翻转操作后，将得到qwqwq；串z无论进行多少次翻转操作，都不会被改变。

贪玩的绿绿进行了若干次（可能为 0 次）翻转操作。

淘气的绿绿又展示出了一个非空串 S，并表示 S 是最终的串 R 的前缀。现在，他想考考 Yazid，初始的串 R 的长度可能是多少。

Yazid 找到了正在参加清华校赛的你，请你来帮他解决这个问题。但聪明的 Yazid 发现，所有超过 |S| 的整数都一定是 R 的可能长度，因此你只需要告诉他不超过的 |S| 的 R 的可能长度即可。

为了帮助你理解问题，Yazid 还将对一些概念和记号做出解释：

• 对于一个串 S，|S| 表示的是该串的长度。

• 对于一个串 S，我们定义串 T 是它的前缀，当且仅当 |T|≤|S|，且对于任意整数 i 满足 1≤i≤|T|，都有 T 的左起第 i 个字符与 S 的左起第 i 个字符相同。（形象地理解，即 T 在 S 的前部出现）

• 如：abc是abcdefg的前缀，aba不为abba的前缀，z为z的前缀，空串为任意一个串的前缀。

## 输入格式

从标准输入读入数据。

输入包含多组数据，第一行一个整数 T 表示数据组数。接下来依次描述每组数据，对于每组数据：

• 一行一个仅由小写字母组成的非空字符串 S。

## 输出格式

输出到标准输出。

对于每组数据，输出 1 行：

• 从小到大输出 |R| 的所有不超过 |S| 的可能值，所有值之间用单个空格隔开。

## 样例输入

```plain
4
abcdcb
qwqwq
qaqaqqq
carnation
```

## 样例输出

```plain
4 6
2 3 4 5
6 7
9
```

## 子任务

本题有 1 个子任务，共 4 个测试点，与考场测试数据相同。只有通过所有的测试点你才能拿到本题的分数。

保证 |S|≤106，∑|S|≤5×106。

∑|S| 表示的是单个测试点中所有数据 |S| 的总和。

语言及编译选项信息

| #    | 名称           | 编译器  | 额外参数                      | 代码长度限制（B） |
| :--- | :------------- | :------ | :---------------------------- | :---------------- |
| 0    | g++ with std14 | g++     | -O2 -std=c++14 -DONLINE_JUDGE | 65536             |
| 1    | g++            | g++     | -O2 -DONLINE_JUDGE            | 65536             |
| 2    | gcc with std11 | gcc     | -O2 -std=c11 -DONLINE_JUDGE   | 65536             |
| 3    | gcc            | gcc     | -O2 -DONLINE_JUDGE            | 65536             |
| 4    | java           | javac   |                               | 65536             |
| 5    | python         | python  |                               | 65536             |
| 6    | python3        | python3 |                               | 65536             |



# 

多看PPT多看PPT多看PPT，重要的事情说三遍！！把【可能有的人会用到】仔细过一遍，里面关于120个硬币的答案有问题，答案在算法笔记本中，不过这个题我们这届没考，考的都是其他的常规题目。把我说的那个文档弄懂，概念第一个PPT记住，考试不是问题，fight~~
                                ——爱你们深沉的XIAO学姐

### 李朝辉画的重点

题型

单选20

填空 20 如理解O  omega 最优子结构有什么意义

![image-20211223091216130](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211223091216130.png)

解答题 （算法题） 30

算法设计 （手写代码）

重点题型，使用多种方法解决01背包问题

### 13年



### 14年

by——裴仪瑶

 

 

选择填空：

\1.     哪种算法是深度优先、广度优先、

回溯,分支限界

\2.     归并排序的时间复杂度

和快排一样Nlogn

\3.     哪两种复杂性

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

\4.     T (n) = O (f (n))、T(n)=Ω(g(n))、T(n)=Θ(f(n))分别是什么含义，给两个函数用以上三种符号表示。

![image-20211229142119640](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229142119640.png)



![image-20211229142303308](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229142303308.png)

![image-20211229142240602](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229142240602.png)

![image-20211229141934187](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229141934187.png)



\5.     快速排序，写出一次排序的结果

\6.     0/1背包问题是什么树，TSP问题是什么树

\7.     贪心法、动态规划法。。。。哪个是自底向上的

简答，算结果：

\1.     ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

\2.     TSP问题算最短路径

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

\3.     给出若干会议的开始时间和结束时间，算出最合理的安排

 不间隔问题，按结束时间排序

大题：

\1.     ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

以及T（n）等于其他函数的时候。

\2.     用回溯法、分支限界法、动态规划法画出0/1背包问题的求解过程

\3.     ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

### 15年-16年

0/1背包问题的前世今生
每一节的PPT最后的问题与解答大家都看一下吧。
比如：
分治法中的最大字段和问题；(回顾)
动态规划的广告牌问题；（回顾）

算法:哈夫曼 （回顾）最短路径 算法的原理 背包问题
老师上课的作业题

算法分析与设计

### 0/1背包问题的前世今生

0/1背包问题，需要考虑给定n个物品集合的所有子集，找出所有可能的子集(总重量不超过背包容量的子集)，计算每个子集的总价值，然后在他们中找到价值最大的子集。

\1.     蛮力法

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)对于一个具有n个元素的集合，其子集数量是2n，所以，不论生成子集的算法效率有多高，蛮力法都会导致一个![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)的算法。

2． 回溯法

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png)

3.分支限界法

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

4.贪心法

​    ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

5.动态规划法

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image011.png)

### 另外

每一节的PPT最后的问题与解答大家都看一下吧。

比如：

分治法中的最大字段和问题；

动态规划的广告牌问题；

 二、所用算法的基本思想及复杂度分析：

### 四种方法背包问题

**1.****蛮力法求解****0/1****背包问题：**

**1****）基本思想：**

对于有n种可选物品的0/1背包问题，其解空间由长度为n的0-1向量组成,可用子集数表示。在搜索解空间树时，深度优先遍历，搜索每一个结点，无论是否可能产生最优解，都遍历至叶子结点，记录每次得到的装入总价值，然后记录遍历过的最大价值。

**2****）复杂度分析****：**

蛮力法求解0/1背包问题的时间复杂度为：![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)。

**2.****动态规划法求解****0/1****背包问题：**

**1****）基本思想：**

令![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)表示在前![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)个物品中能够装入容量为![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)的背包中的物品的最大值，则可以得到如下动态函数：

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)

按照下述方法来划分阶段：第一阶段，只装入前1个物品，确定在各种情况下的背包能够得到的最大价值；第二阶段，只装入前2个物品，确定在各种情况下的背包能够得到的最大价值；以此类推，直到第![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)个阶段。最后，![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)便是在容量为![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)的背包中装入![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)个物品时取得的最大价值。

**2****）复杂度分析：**

动态规划法求解0/1背包问题的时间复杂度为：![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png)。

**3.****回溯法求解****0/1****背包问题：**

**1****）基本思想：**

回溯法：为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding function)来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。这种具有限界函数的深度优先生成法称为回溯法。

对于有n种可选物品的0/1背包问题，其解空间由长度为n的0-1向量组成,可用子集数表示。在搜索解空间树时，只要其左儿子结点是一个可行结点，搜索就进入左子树。当右子树中有可能包含最优解时就进入右子树搜索。

**2****）复杂度分析****：**

最不理想的情况下，回溯法求解0/1背包问题的时间复杂度为：![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)。由于其对蛮力法进行优化后的算法，其复杂度一般比蛮力法要小。

空间复杂度：有![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)个物品，即最多递归![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)层，存储物品信息就是一个一维数组，即回溯法求解0/1背包问题的空间复杂度为![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png)。

**4.****分支限界法求解背包问题：**

**1****）基本思想：**

分支限界法类似于回溯法，也是在问题的解空间上搜索问题解的算法。一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出解空间中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。

首先，要对输入数据进行预处理，将各物品依其单位重量价值从大到小进行排列。

在下面描述的优先队列分支限界法中，节点的优先级由已装袋的物品价值加上剩下的最大单位重量价值的物品装满剩余容量的价值和。

算法首先检查当前扩展结点的左儿子结点的可行性。如果该左儿子结点是可行结点，则将它加入到子集树和活结点优先队列中。当前扩展结点的右儿子结点一定是可行结点，仅当右儿子结点满足上界约束时才将它加入子集树和活结点优先队列。当扩展到叶节点时为问题的最优值。

**2****）复杂度分析****：**

分支限界法求解0/1背包问题的时间复杂度为：![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)。

### 三算法课后题

\1.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)

\2.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

\3.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png)

\4.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

\5.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png)

\6.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png)

\7.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png)

\8.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image011.png)

\9.  ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image013.png)

\10.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image015.png)

\11.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image017.jpg)

\12.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image019.png)

\13.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png)

\14.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image023.png)

\15.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image025.png)

\16.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image027.png)

\17.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image029.png)

\18.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image031.png)

\19.         q![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image033.png)

\20.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image035.png)

\21.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image037.png)

\22.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image039.png)

\23.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image041.png)

\24.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image043.png)

\25.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image045.png)

\26.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image047.png)

\27.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image049.png)

\28.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image051.png)

\29.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image053.png)

\30.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image055.png)

\31.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image057.png)

\32.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image059.png)

\33.         ![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image061.png)

### 19算法期末：（努力了，只记得这点了，这届考的略硬核）

一、           选择题（20 分，10 道，一道  2 分）
（1）  算法的五个特性 PFOID

pfoid

可行性 无穷性 输出输入 确定性

possibility

Input

output

finite

![image-20211229214751718](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229214751718.png)（2）  打印所有素数违背了五大特性中的哪一个（有穷性)

有穷性

（3）  自底向上的算法（动态规划）

动态规划，重叠子问题

（4）  什么算法不能用分治法解决

子问题与原问题类型不一致？

（5）  回溯法用（深度优先）

深度优先

（6)  c 个学生，记录它们的成绩的和  sum，选语句

​			sum->sum+t
​			c->c+1

二、           判断题（20 分，10 道）就记得这几个，其他几个应该不难
（1）动态规划最优化原理和子问题重叠？

什么是最优子结构：最优解包含子问题的解称为最优子结构

（2）递归设计总是需要初始值？

确实，大多数情况下是这样的

（3）Best,worst,average 时间，其中 worst 具有最大的操作性和实用价值？

应该是平均时间复杂度比较有意义

三、           填空题（20 分，10 道）
（1）  给出了一个数列，求快排第一趟排序

![image-20211229220726002](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229220726002.png)（2）  算法分析时间复杂度和（空间)复杂度

嗯背就行

（3)  折半查找的最坏情况的时间复杂度。

注意，折半查找的中轴始终在数组中间，所以还是nlogn

（4）  求时间复杂度
For(int i=0;i<=n;i++) 

​	For(int j=0;j<=2n;j++)

O(n^2)

T(n)=2n^2<3*(N平方)

（5）  贪心算法：最优子结构和贪心策略

**问题的最优解包含子问题的最优解**

（6）  T(n)=aT(n/b)+cn 这个公式，给了一个公式，求  O（）。

二分法的时间复杂度计算

![image-20211229231858625](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229231858625.png)

（7）  Prim、快排、哈夫曼算法中，哪个不属于贪心算法（快排）

​			贪心 二分 贪心

（8）  **动态规划法存储  subsolution 的目的是什么**。

因为动态规划法是最优子结构问题，**子问题的最优解包含最优解**

（9）  O、Θ、Ω哪个用来作为算法确切的标准？？（好像是这么回事）

O

![image-20211229231338953](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229231338953.png)

时间复杂度

这里是每年必考的重点！重点！！！！

（10）  下面这张图出了题
A,B 两个算法，一个是  2T(n/2)+n，一个是  aT(n/4)+n，A 小于  B，求  a 的最 大值。需要会推。

[(35条消息) 复杂度分析——求解递归方程（方法+例题）_Yeira的博客-CSDN博客_解递归方程](https://blog.csdn.net/weixin_43865875/article/details/119283075)

![image-20211229144839230](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229144839230.png)四、           求解（25 分，5 道）
（1）  办活动，给出了开始时间和结束时间，要求有最大兼容量（区间调度的变体），写出子集。
（2）  01 背包问题回溯法，画解空间树。
（3）  有  7 个小区，给出了坐标，现在要建医疗诊所，求建在哪里（邮局问 题变体，是中位数）。
（4）  任务分配问题，画分支界限树。
（5)  TSP 求路径和最小距离，给了一个图

回溯（试一试）

五、           算法设计题（15 分，2 道）
（1）n 个人在一个服务窗口，给出了每个人服务的时间，求总的最小等待 时间。（可以先排序，再计算）

按照结束时间排序

（2）展览馆办活动，给出了开始时间、结束时间、价值，动态规划求总价 值最大（**带权区间调度**的变体)

区间调度问题

### 广告牌问题

![image-20211229231555305](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229231555305.png)

### 贪心区间调度问题

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-abd5f9bfbcf435c8407dc803505688f3_b.gif&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643384433&t=efa6b139e5ec9f8fc5e351cf0d085937)



### 带权区间调度问题

![image-20211229234359086](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229234359086.png)

![image-20211229233841173](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229233841173.png



![image-20211229234459007](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229234459007.png)

![image-20211229233929946](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229233929946.png)

![image-20211229233952955](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229233952955.png)

求解最优方案：
看是否选了当前任务j jj(根据递推式)，若选了，则跳到O P T ( p ( j ) ) OPT(p(j))OPT(p(j))，继续查找方案；若没选，则跳到O P T ( j − 1 ) OPT(j-1)OPT(j−1)，继续查找方案。
------------------------------------------------
版权声明：本文为CSDN博主「小菜菜forever」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_37657182/article/details/102891495

### 20年算法期末

算法：
考得跟去年 70%一样，多出来 10 个判断和 10 个选择 30 分选择 30 分判断
10 分填空（填空和去年学姐整理的一模一样）
14 分写解（任务分配画分支限界图，01 背包画回溯的图，TSP 直接写结果） 6 分算法设计（只有一个带权区间调度）
一点也不硬核。。。。。。我们都觉得挺简单
总结：只要大家平常上课够菜（每次做课堂题，稍微难一点就只有 1/3 的人做对， 因为大家都没听课，要么是乱选的，李老师准把我们当 nt 了），考试就够简单，有手就行

![image-20211229233542072](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229233542072.png)

\6. 能采用贪心算法求最优解的问题，一般具有的重要性质为：（A）

A. 最优子结构性质与贪心选择性质

B．重叠子问题性质与贪心选择性质

C．最优子结构性质与重叠子问题性质

 

D. 预排序与递归调用



##  选课指南



![image-20211229105057732](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229105057732.png)

选课优先级

![image-20211229113203746](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229113203746.png)

| 优先级 | 课程                                                         | 教师   | 容量 |
| ------ | ------------------------------------------------------------ | ------ | ---- |
| 1      | **软件过程改进**                                             | 袁玉宇 | 100  |
| 2      | **电子商务系统**（期末+pre）                                 | 牛琨   | 60   |
| 3      | **大数据原理与技术**（听说实验挺难）                         | 孙鹏飞 | 90   |
| 6      | 软件项目管理（）                                             | 韩万江 | ？   |
| 6      | 人工智能围棋基础                                             | 卢本婕 |      |
| 5      | **网络安全与网络管理**                                       | 陆天波 | ？   |
| 随缘   | 移动终端软件开发技术                                         | 谢坤   | ？   |
| 随缘   | 分布式计算（听说挺难）                                       | 卢本婕 | ？   |
| 随缘   | 未来互联网新技术（雷区）                                     | 张波   | ?    |
| 随缘   | 下一代网络技术（雷区）                                       | 雷友珣 | ?    |
|        | **云计算技术**（听说雷区又累又硬核）cyd的云计算 工作量比较大 | 崔毅东 | ?？  |
| 随缘   | 软件体系结构（雷区）                                         | 王祎   | ？   |
|        | 通信协议测试（没选通信协议）（雷区）                         | 雷友询 | ？   |
|        |                                                              |        |      |
|        |                                                              |        |      |
|        |                                                              |        |      |
|        |                                                              |        |      |
|        |                                                              |        |      |
|        |                                                              |        |      |

电商

大数据

我

电商

wxf

|                |                                     |        |            |      |
| -------------- | ----------------------------------- | ------ | ---------- | ---- |
| 软件过程改进   | TDD2021                             | 大三下 | 袁玉宇老师 |      |
| 移动终端开发   | Android Developing                  | 大三下 | 谢坤老师   |      |
| 大数据原理技术 | BigData Hadoop MapReduce Experiment | 大三下 | 孙鹏飞老师 |      |
| 云计算技术     | Cloud Compute Technology            | 大三下 | 崔毅东老师 |      |

![image-20211229111522524](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229111522524.png)

求助学长学姐，大三下选修课有啥推荐和坑吗？

意向出国，想保持GPA，T_T





计网：	

计网概念呢

网络类型以太，电信 分组

网络软件协议栈

原语

服务

服务

网络实例

互联网

电话网

重要的英文缩写名词

无线局域网特征

物理层

传输物质的种类和限制

wireless的种类和频谱

通行卫星

物理层数字调制和复用

复用相移动

码分复用

各种复用

交换的基本原理（面向连接的交换，数据包是一个面向非连接的）

数据包的传送

移动通行技术

3G4G

把话音数据化了

数据链路层

frame 第四层segment

差错检测和纠正

汉明码

奇偶校验

检错

窗口

滑动窗口

gobacktoN原理

ppt里面介绍的高级链路数据控制协议

http

mac层

有线，wireless net

信道分配冲突

传统wireless

引爆终端

多路访问原理和机制

经典以太网和无线网

以太网的格式

mac地址到底多长

数据链路层交换

教材最后一节XXX工作在那一层

网桥交换机，路由器，网管2,3,4

学习性网桥（对应mac和ip）（重点）

网络层

分组

packet

iPv4 ipv6

不用背，要理解，给一大堆数据要识别出来，图会给你，会交叉

分组概念的基本原理

路由算法域内（RUP,），域间(PGP)

距离矢量，链路交换

邻居给我的东西清楚

网络的拥塞控制原理和机制

小桶大带宽和大桶小带宽，过宽

网络层 ip协议

v4 v6的地址表达，ip地址怎么聚合和拆分寻址，怎么算ip，怎么看那个端口 

路由最重要

作业看一看

ip地址的寻址和转发（重点）、

传输层

segment

frame packet forwarding

端的概念和基本原理

传世层的连接和释放，拥塞控制 TCP UDP 面向非连接的，tcp最重要概念原理连接释放滑动窗口拥塞控制

慢启动和原理，快速恢复，TCP连接保持-计时器（），三个—timer（了解和掌握）

应用层

概念和原理

DNS

是啥

Email怎么存取传

www的原理和

http协议的基本原理

一层一层，是魔鬼的步伐

一层音

老师强调实验的和作业，强调跨层方面的思考，分析过程，涉及各个层面，

